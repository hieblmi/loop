// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: client.proto

package looprpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SwapClient_LoopOut_FullMethodName                      = "/looprpc.SwapClient/LoopOut"
	SwapClient_LoopIn_FullMethodName                       = "/looprpc.SwapClient/LoopIn"
	SwapClient_Monitor_FullMethodName                      = "/looprpc.SwapClient/Monitor"
	SwapClient_ListSwaps_FullMethodName                    = "/looprpc.SwapClient/ListSwaps"
	SwapClient_SwapInfo_FullMethodName                     = "/looprpc.SwapClient/SwapInfo"
	SwapClient_AbandonSwap_FullMethodName                  = "/looprpc.SwapClient/AbandonSwap"
	SwapClient_LoopOutTerms_FullMethodName                 = "/looprpc.SwapClient/LoopOutTerms"
	SwapClient_LoopOutQuote_FullMethodName                 = "/looprpc.SwapClient/LoopOutQuote"
	SwapClient_GetLoopInTerms_FullMethodName               = "/looprpc.SwapClient/GetLoopInTerms"
	SwapClient_GetLoopInQuote_FullMethodName               = "/looprpc.SwapClient/GetLoopInQuote"
	SwapClient_Probe_FullMethodName                        = "/looprpc.SwapClient/Probe"
	SwapClient_GetL402Tokens_FullMethodName                = "/looprpc.SwapClient/GetL402Tokens"
	SwapClient_GetLsatTokens_FullMethodName                = "/looprpc.SwapClient/GetLsatTokens"
	SwapClient_FetchL402Token_FullMethodName               = "/looprpc.SwapClient/FetchL402Token"
	SwapClient_GetInfo_FullMethodName                      = "/looprpc.SwapClient/GetInfo"
	SwapClient_StopDaemon_FullMethodName                   = "/looprpc.SwapClient/StopDaemon"
	SwapClient_GetLiquidityParams_FullMethodName           = "/looprpc.SwapClient/GetLiquidityParams"
	SwapClient_SetLiquidityParams_FullMethodName           = "/looprpc.SwapClient/SetLiquidityParams"
	SwapClient_SuggestSwaps_FullMethodName                 = "/looprpc.SwapClient/SuggestSwaps"
	SwapClient_ListReservations_FullMethodName             = "/looprpc.SwapClient/ListReservations"
	SwapClient_InstantOut_FullMethodName                   = "/looprpc.SwapClient/InstantOut"
	SwapClient_InstantOutQuote_FullMethodName              = "/looprpc.SwapClient/InstantOutQuote"
	SwapClient_ListInstantOuts_FullMethodName              = "/looprpc.SwapClient/ListInstantOuts"
	SwapClient_NewStaticAddress_FullMethodName             = "/looprpc.SwapClient/NewStaticAddress"
	SwapClient_ListUnspentDeposits_FullMethodName          = "/looprpc.SwapClient/ListUnspentDeposits"
	SwapClient_WithdrawDeposits_FullMethodName             = "/looprpc.SwapClient/WithdrawDeposits"
	SwapClient_ListStaticAddressDeposits_FullMethodName    = "/looprpc.SwapClient/ListStaticAddressDeposits"
	SwapClient_ListStaticAddressWithdrawals_FullMethodName = "/looprpc.SwapClient/ListStaticAddressWithdrawals"
	SwapClient_ListStaticAddressSwaps_FullMethodName       = "/looprpc.SwapClient/ListStaticAddressSwaps"
	SwapClient_GetStaticAddressSummary_FullMethodName      = "/looprpc.SwapClient/GetStaticAddressSummary"
	SwapClient_StaticAddressLoopIn_FullMethodName          = "/looprpc.SwapClient/StaticAddressLoopIn"
)

// SwapClientClient is the client API for SwapClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SwapClient is a service that handles the client side process of onchain/offchain
// swaps. The service is designed for a single client.
type SwapClientClient interface {
	// loop: `out`
	// LoopOut initiates an loop out swap with the given parameters. The call
	// returns after the swap has been set up with the swap server. From that
	// point onwards, progress can be tracked via the SwapStatus stream that is
	// returned from Monitor().
	LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	// loop: `in`
	// LoopIn initiates a loop in swap with the given parameters. The call
	// returns after the swap has been set up with the swap server. From that
	// point onwards, progress can be tracked via the SwapStatus stream
	// that is returned from Monitor().
	LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	// loop: `monitor`
	// Monitor will return a stream of swap updates for currently active swaps.
	Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SwapStatus], error)
	// loop: `listswaps`
	// ListSwaps returns a list of all currently known swaps and their current
	// status.
	ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error)
	// loop: `swapinfo`
	// SwapInfo returns all known details about a single swap.
	SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error)
	// loop: `abandonswap`
	// AbandonSwap allows the client to abandon a swap.
	AbandonSwap(ctx context.Context, in *AbandonSwapRequest, opts ...grpc.CallOption) (*AbandonSwapResponse, error)
	// loop: `terms`
	// LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error)
	// loop: `quote`
	// LoopOutQuote returns a quote for a loop out swap with the provided
	// parameters.
	LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error)
	// loop: `terms`
	// GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error)
	// loop: `quote`
	// GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error)
	// Probe asks he sever to probe the route to us to have a better upfront
	// estimate about routing fees when loopin-in.
	Probe(ctx context.Context, in *ProbeRequest, opts ...grpc.CallOption) (*ProbeResponse, error)
	// loop: `listauth`
	// GetL402Tokens returns all L402 tokens the daemon ever paid for.
	GetL402Tokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error)
	// Deprecated: use GetL402Tokens.
	// This API is provided to maintain backward compatibility with gRPC clients
	// (e.g. `loop listauth`, Terminal Web, RTL).
	// Type LsatToken used by GetLsatTokens in the past was renamed to L402Token,
	// but this does not affect binary encoding, so we can use type L402Token here.
	GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error)
	// loop: `fetchl402`
	// FetchL402Token fetches an L402 token from the server, this is required in
	// order to receive reservation notifications from the server.
	FetchL402Token(ctx context.Context, in *FetchL402TokenRequest, opts ...grpc.CallOption) (*FetchL402TokenResponse, error)
	// loop: `getinfo`
	// GetInfo gets basic information about the loop daemon.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// loop: `stop`
	// StopDaemon instructs the daemon to shut down gracefully.
	StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error)
	// loop: `getparams`
	// GetLiquidityParams gets the parameters that the daemon's liquidity manager
	// is currently configured with. This may be nil if nothing is configured.
	// [EXPERIMENTAL]: endpoint is subject to change.
	GetLiquidityParams(ctx context.Context, in *GetLiquidityParamsRequest, opts ...grpc.CallOption) (*LiquidityParameters, error)
	// loop: `setparams`
	// SetLiquidityParams sets a new set of parameters for the daemon's liquidity
	// manager. Note that the full set of parameters must be provided, because
	// this call fully overwrites our existing parameters.
	// [EXPERIMENTAL]: endpoint is subject to change.
	SetLiquidityParams(ctx context.Context, in *SetLiquidityParamsRequest, opts ...grpc.CallOption) (*SetLiquidityParamsResponse, error)
	// loop: `suggestswaps`
	// SuggestSwaps returns a list of recommended swaps based on the current
	// state of your node's channels and it's liquidity manager parameters.
	// Note that only loop out suggestions are currently supported.
	// [EXPERIMENTAL]: endpoint is subject to change.
	SuggestSwaps(ctx context.Context, in *SuggestSwapsRequest, opts ...grpc.CallOption) (*SuggestSwapsResponse, error)
	// loop: `listreservations`
	// ListReservations returns a list of all reservations the server opened to us.
	ListReservations(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ListReservationsResponse, error)
	// loop: `instantout`
	// InstantOut initiates an instant out swap with the given parameters.
	InstantOut(ctx context.Context, in *InstantOutRequest, opts ...grpc.CallOption) (*InstantOutResponse, error)
	// loop: `instantoutquote`
	// InstantOutQuote returns a quote for an instant out swap with the provided
	// parameters.
	InstantOutQuote(ctx context.Context, in *InstantOutQuoteRequest, opts ...grpc.CallOption) (*InstantOutQuoteResponse, error)
	// loop: `listinstantouts`
	// ListInstantOuts returns a list of all currently known instant out swaps and
	// their current status.
	ListInstantOuts(ctx context.Context, in *ListInstantOutsRequest, opts ...grpc.CallOption) (*ListInstantOutsResponse, error)
	// loop: `static newstaticaddress`
	// NewStaticAddress requests a new static address for loop-ins from the server.
	NewStaticAddress(ctx context.Context, in *NewStaticAddressRequest, opts ...grpc.CallOption) (*NewStaticAddressResponse, error)
	// loop: `static listunspentdeposits`
	// ListUnspentDeposits returns a list of utxos deposited at a static address.
	ListUnspentDeposits(ctx context.Context, in *ListUnspentDepositsRequest, opts ...grpc.CallOption) (*ListUnspentDepositsResponse, error)
	// loop:`static withdraw`
	// WithdrawDeposits withdraws a selection or all deposits of a static address.
	WithdrawDeposits(ctx context.Context, in *WithdrawDepositsRequest, opts ...grpc.CallOption) (*WithdrawDepositsResponse, error)
	// loop:`listdeposits`
	// ListStaticAddressDeposits returns a list of filtered static address
	// deposits.
	ListStaticAddressDeposits(ctx context.Context, in *ListStaticAddressDepositsRequest, opts ...grpc.CallOption) (*ListStaticAddressDepositsResponse, error)
	// loop:`listwithdrawals`
	// ListStaticAddressWithdrawals returns a list of static address withdrawals.
	ListStaticAddressWithdrawals(ctx context.Context, in *ListStaticAddressWithdrawalRequest, opts ...grpc.CallOption) (*ListStaticAddressWithdrawalResponse, error)
	// loop:`listswaps`
	// ListStaticAddressSwaps returns a list of filtered static address
	// swaps.
	ListStaticAddressSwaps(ctx context.Context, in *ListStaticAddressSwapsRequest, opts ...grpc.CallOption) (*ListStaticAddressSwapsResponse, error)
	// loop:`static summary`
	// GetStaticAddressSummary returns a summary of static address related
	// statistics.
	GetStaticAddressSummary(ctx context.Context, in *StaticAddressSummaryRequest, opts ...grpc.CallOption) (*StaticAddressSummaryResponse, error)
	// loop:`static`
	// StaticAddressLoopIn initiates a static address loop-in swap.
	StaticAddressLoopIn(ctx context.Context, in *StaticAddressLoopInRequest, opts ...grpc.CallOption) (*StaticAddressLoopInResponse, error)
}

type swapClientClient struct {
	cc grpc.ClientConnInterface
}

func NewSwapClientClient(cc grpc.ClientConnInterface) SwapClientClient {
	return &swapClientClient{cc}
}

func (c *swapClientClient) LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, SwapClient_LoopOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, SwapClient_LoopIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SwapStatus], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SwapClient_ServiceDesc.Streams[0], SwapClient_Monitor_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MonitorRequest, SwapStatus]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SwapClient_MonitorClient = grpc.ServerStreamingClient[SwapStatus]

func (c *swapClientClient) ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSwapsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListSwaps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwapStatus)
	err := c.cc.Invoke(ctx, SwapClient_SwapInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) AbandonSwap(ctx context.Context, in *AbandonSwapRequest, opts ...grpc.CallOption) (*AbandonSwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbandonSwapResponse)
	err := c.cc.Invoke(ctx, SwapClient_AbandonSwap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutTermsResponse)
	err := c.cc.Invoke(ctx, SwapClient_LoopOutTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutQuoteResponse)
	err := c.cc.Invoke(ctx, SwapClient_LoopOutQuote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InTermsResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetLoopInTerms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InQuoteResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetLoopInQuote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) Probe(ctx context.Context, in *ProbeRequest, opts ...grpc.CallOption) (*ProbeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProbeResponse)
	err := c.cc.Invoke(ctx, SwapClient_Probe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetL402Tokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokensResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetL402Tokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokensResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetLsatTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) FetchL402Token(ctx context.Context, in *FetchL402TokenRequest, opts ...grpc.CallOption) (*FetchL402TokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchL402TokenResponse)
	err := c.cc.Invoke(ctx, SwapClient_FetchL402Token_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInfoResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopDaemonResponse)
	err := c.cc.Invoke(ctx, SwapClient_StopDaemon_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLiquidityParams(ctx context.Context, in *GetLiquidityParamsRequest, opts ...grpc.CallOption) (*LiquidityParameters, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LiquidityParameters)
	err := c.cc.Invoke(ctx, SwapClient_GetLiquidityParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SetLiquidityParams(ctx context.Context, in *SetLiquidityParamsRequest, opts ...grpc.CallOption) (*SetLiquidityParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLiquidityParamsResponse)
	err := c.cc.Invoke(ctx, SwapClient_SetLiquidityParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SuggestSwaps(ctx context.Context, in *SuggestSwapsRequest, opts ...grpc.CallOption) (*SuggestSwapsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SuggestSwapsResponse)
	err := c.cc.Invoke(ctx, SwapClient_SuggestSwaps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListReservations(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ListReservationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReservationsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListReservations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) InstantOut(ctx context.Context, in *InstantOutRequest, opts ...grpc.CallOption) (*InstantOutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstantOutResponse)
	err := c.cc.Invoke(ctx, SwapClient_InstantOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) InstantOutQuote(ctx context.Context, in *InstantOutQuoteRequest, opts ...grpc.CallOption) (*InstantOutQuoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstantOutQuoteResponse)
	err := c.cc.Invoke(ctx, SwapClient_InstantOutQuote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListInstantOuts(ctx context.Context, in *ListInstantOutsRequest, opts ...grpc.CallOption) (*ListInstantOutsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInstantOutsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListInstantOuts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) NewStaticAddress(ctx context.Context, in *NewStaticAddressRequest, opts ...grpc.CallOption) (*NewStaticAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewStaticAddressResponse)
	err := c.cc.Invoke(ctx, SwapClient_NewStaticAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListUnspentDeposits(ctx context.Context, in *ListUnspentDepositsRequest, opts ...grpc.CallOption) (*ListUnspentDepositsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUnspentDepositsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListUnspentDeposits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) WithdrawDeposits(ctx context.Context, in *WithdrawDepositsRequest, opts ...grpc.CallOption) (*WithdrawDepositsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WithdrawDepositsResponse)
	err := c.cc.Invoke(ctx, SwapClient_WithdrawDeposits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListStaticAddressDeposits(ctx context.Context, in *ListStaticAddressDepositsRequest, opts ...grpc.CallOption) (*ListStaticAddressDepositsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStaticAddressDepositsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListStaticAddressDeposits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListStaticAddressWithdrawals(ctx context.Context, in *ListStaticAddressWithdrawalRequest, opts ...grpc.CallOption) (*ListStaticAddressWithdrawalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStaticAddressWithdrawalResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListStaticAddressWithdrawals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) ListStaticAddressSwaps(ctx context.Context, in *ListStaticAddressSwapsRequest, opts ...grpc.CallOption) (*ListStaticAddressSwapsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStaticAddressSwapsResponse)
	err := c.cc.Invoke(ctx, SwapClient_ListStaticAddressSwaps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetStaticAddressSummary(ctx context.Context, in *StaticAddressSummaryRequest, opts ...grpc.CallOption) (*StaticAddressSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StaticAddressSummaryResponse)
	err := c.cc.Invoke(ctx, SwapClient_GetStaticAddressSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) StaticAddressLoopIn(ctx context.Context, in *StaticAddressLoopInRequest, opts ...grpc.CallOption) (*StaticAddressLoopInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StaticAddressLoopInResponse)
	err := c.cc.Invoke(ctx, SwapClient_StaticAddressLoopIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapClientServer is the server API for SwapClient service.
// All implementations must embed UnimplementedSwapClientServer
// for forward compatibility.
//
// SwapClient is a service that handles the client side process of onchain/offchain
// swaps. The service is designed for a single client.
type SwapClientServer interface {
	// loop: `out`
	// LoopOut initiates an loop out swap with the given parameters. The call
	// returns after the swap has been set up with the swap server. From that
	// point onwards, progress can be tracked via the SwapStatus stream that is
	// returned from Monitor().
	LoopOut(context.Context, *LoopOutRequest) (*SwapResponse, error)
	// loop: `in`
	// LoopIn initiates a loop in swap with the given parameters. The call
	// returns after the swap has been set up with the swap server. From that
	// point onwards, progress can be tracked via the SwapStatus stream
	// that is returned from Monitor().
	LoopIn(context.Context, *LoopInRequest) (*SwapResponse, error)
	// loop: `monitor`
	// Monitor will return a stream of swap updates for currently active swaps.
	Monitor(*MonitorRequest, grpc.ServerStreamingServer[SwapStatus]) error
	// loop: `listswaps`
	// ListSwaps returns a list of all currently known swaps and their current
	// status.
	ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsResponse, error)
	// loop: `swapinfo`
	// SwapInfo returns all known details about a single swap.
	SwapInfo(context.Context, *SwapInfoRequest) (*SwapStatus, error)
	// loop: `abandonswap`
	// AbandonSwap allows the client to abandon a swap.
	AbandonSwap(context.Context, *AbandonSwapRequest) (*AbandonSwapResponse, error)
	// loop: `terms`
	// LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(context.Context, *TermsRequest) (*OutTermsResponse, error)
	// loop: `quote`
	// LoopOutQuote returns a quote for a loop out swap with the provided
	// parameters.
	LoopOutQuote(context.Context, *QuoteRequest) (*OutQuoteResponse, error)
	// loop: `terms`
	// GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(context.Context, *TermsRequest) (*InTermsResponse, error)
	// loop: `quote`
	// GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(context.Context, *QuoteRequest) (*InQuoteResponse, error)
	// Probe asks he sever to probe the route to us to have a better upfront
	// estimate about routing fees when loopin-in.
	Probe(context.Context, *ProbeRequest) (*ProbeResponse, error)
	// loop: `listauth`
	// GetL402Tokens returns all L402 tokens the daemon ever paid for.
	GetL402Tokens(context.Context, *TokensRequest) (*TokensResponse, error)
	// Deprecated: use GetL402Tokens.
	// This API is provided to maintain backward compatibility with gRPC clients
	// (e.g. `loop listauth`, Terminal Web, RTL).
	// Type LsatToken used by GetLsatTokens in the past was renamed to L402Token,
	// but this does not affect binary encoding, so we can use type L402Token here.
	GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error)
	// loop: `fetchl402`
	// FetchL402Token fetches an L402 token from the server, this is required in
	// order to receive reservation notifications from the server.
	FetchL402Token(context.Context, *FetchL402TokenRequest) (*FetchL402TokenResponse, error)
	// loop: `getinfo`
	// GetInfo gets basic information about the loop daemon.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// loop: `stop`
	// StopDaemon instructs the daemon to shut down gracefully.
	StopDaemon(context.Context, *StopDaemonRequest) (*StopDaemonResponse, error)
	// loop: `getparams`
	// GetLiquidityParams gets the parameters that the daemon's liquidity manager
	// is currently configured with. This may be nil if nothing is configured.
	// [EXPERIMENTAL]: endpoint is subject to change.
	GetLiquidityParams(context.Context, *GetLiquidityParamsRequest) (*LiquidityParameters, error)
	// loop: `setparams`
	// SetLiquidityParams sets a new set of parameters for the daemon's liquidity
	// manager. Note that the full set of parameters must be provided, because
	// this call fully overwrites our existing parameters.
	// [EXPERIMENTAL]: endpoint is subject to change.
	SetLiquidityParams(context.Context, *SetLiquidityParamsRequest) (*SetLiquidityParamsResponse, error)
	// loop: `suggestswaps`
	// SuggestSwaps returns a list of recommended swaps based on the current
	// state of your node's channels and it's liquidity manager parameters.
	// Note that only loop out suggestions are currently supported.
	// [EXPERIMENTAL]: endpoint is subject to change.
	SuggestSwaps(context.Context, *SuggestSwapsRequest) (*SuggestSwapsResponse, error)
	// loop: `listreservations`
	// ListReservations returns a list of all reservations the server opened to us.
	ListReservations(context.Context, *ListReservationsRequest) (*ListReservationsResponse, error)
	// loop: `instantout`
	// InstantOut initiates an instant out swap with the given parameters.
	InstantOut(context.Context, *InstantOutRequest) (*InstantOutResponse, error)
	// loop: `instantoutquote`
	// InstantOutQuote returns a quote for an instant out swap with the provided
	// parameters.
	InstantOutQuote(context.Context, *InstantOutQuoteRequest) (*InstantOutQuoteResponse, error)
	// loop: `listinstantouts`
	// ListInstantOuts returns a list of all currently known instant out swaps and
	// their current status.
	ListInstantOuts(context.Context, *ListInstantOutsRequest) (*ListInstantOutsResponse, error)
	// loop: `static newstaticaddress`
	// NewStaticAddress requests a new static address for loop-ins from the server.
	NewStaticAddress(context.Context, *NewStaticAddressRequest) (*NewStaticAddressResponse, error)
	// loop: `static listunspentdeposits`
	// ListUnspentDeposits returns a list of utxos deposited at a static address.
	ListUnspentDeposits(context.Context, *ListUnspentDepositsRequest) (*ListUnspentDepositsResponse, error)
	// loop:`static withdraw`
	// WithdrawDeposits withdraws a selection or all deposits of a static address.
	WithdrawDeposits(context.Context, *WithdrawDepositsRequest) (*WithdrawDepositsResponse, error)
	// loop:`listdeposits`
	// ListStaticAddressDeposits returns a list of filtered static address
	// deposits.
	ListStaticAddressDeposits(context.Context, *ListStaticAddressDepositsRequest) (*ListStaticAddressDepositsResponse, error)
	// loop:`listwithdrawals`
	// ListStaticAddressWithdrawals returns a list of static address withdrawals.
	ListStaticAddressWithdrawals(context.Context, *ListStaticAddressWithdrawalRequest) (*ListStaticAddressWithdrawalResponse, error)
	// loop:`listswaps`
	// ListStaticAddressSwaps returns a list of filtered static address
	// swaps.
	ListStaticAddressSwaps(context.Context, *ListStaticAddressSwapsRequest) (*ListStaticAddressSwapsResponse, error)
	// loop:`static summary`
	// GetStaticAddressSummary returns a summary of static address related
	// statistics.
	GetStaticAddressSummary(context.Context, *StaticAddressSummaryRequest) (*StaticAddressSummaryResponse, error)
	// loop:`static`
	// StaticAddressLoopIn initiates a static address loop-in swap.
	StaticAddressLoopIn(context.Context, *StaticAddressLoopInRequest) (*StaticAddressLoopInResponse, error)
	mustEmbedUnimplementedSwapClientServer()
}

// UnimplementedSwapClientServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSwapClientServer struct{}

func (UnimplementedSwapClientServer) LoopOut(context.Context, *LoopOutRequest) (*SwapResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoopOut not implemented")
}
func (UnimplementedSwapClientServer) LoopIn(context.Context, *LoopInRequest) (*SwapResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoopIn not implemented")
}
func (UnimplementedSwapClientServer) Monitor(*MonitorRequest, grpc.ServerStreamingServer[SwapStatus]) error {
	return status.Error(codes.Unimplemented, "method Monitor not implemented")
}
func (UnimplementedSwapClientServer) ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSwaps not implemented")
}
func (UnimplementedSwapClientServer) SwapInfo(context.Context, *SwapInfoRequest) (*SwapStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method SwapInfo not implemented")
}
func (UnimplementedSwapClientServer) AbandonSwap(context.Context, *AbandonSwapRequest) (*AbandonSwapResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AbandonSwap not implemented")
}
func (UnimplementedSwapClientServer) LoopOutTerms(context.Context, *TermsRequest) (*OutTermsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoopOutTerms not implemented")
}
func (UnimplementedSwapClientServer) LoopOutQuote(context.Context, *QuoteRequest) (*OutQuoteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoopOutQuote not implemented")
}
func (UnimplementedSwapClientServer) GetLoopInTerms(context.Context, *TermsRequest) (*InTermsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLoopInTerms not implemented")
}
func (UnimplementedSwapClientServer) GetLoopInQuote(context.Context, *QuoteRequest) (*InQuoteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLoopInQuote not implemented")
}
func (UnimplementedSwapClientServer) Probe(context.Context, *ProbeRequest) (*ProbeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Probe not implemented")
}
func (UnimplementedSwapClientServer) GetL402Tokens(context.Context, *TokensRequest) (*TokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetL402Tokens not implemented")
}
func (UnimplementedSwapClientServer) GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLsatTokens not implemented")
}
func (UnimplementedSwapClientServer) FetchL402Token(context.Context, *FetchL402TokenRequest) (*FetchL402TokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchL402Token not implemented")
}
func (UnimplementedSwapClientServer) GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedSwapClientServer) StopDaemon(context.Context, *StopDaemonRequest) (*StopDaemonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopDaemon not implemented")
}
func (UnimplementedSwapClientServer) GetLiquidityParams(context.Context, *GetLiquidityParamsRequest) (*LiquidityParameters, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLiquidityParams not implemented")
}
func (UnimplementedSwapClientServer) SetLiquidityParams(context.Context, *SetLiquidityParamsRequest) (*SetLiquidityParamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetLiquidityParams not implemented")
}
func (UnimplementedSwapClientServer) SuggestSwaps(context.Context, *SuggestSwapsRequest) (*SuggestSwapsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SuggestSwaps not implemented")
}
func (UnimplementedSwapClientServer) ListReservations(context.Context, *ListReservationsRequest) (*ListReservationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListReservations not implemented")
}
func (UnimplementedSwapClientServer) InstantOut(context.Context, *InstantOutRequest) (*InstantOutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InstantOut not implemented")
}
func (UnimplementedSwapClientServer) InstantOutQuote(context.Context, *InstantOutQuoteRequest) (*InstantOutQuoteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InstantOutQuote not implemented")
}
func (UnimplementedSwapClientServer) ListInstantOuts(context.Context, *ListInstantOutsRequest) (*ListInstantOutsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListInstantOuts not implemented")
}
func (UnimplementedSwapClientServer) NewStaticAddress(context.Context, *NewStaticAddressRequest) (*NewStaticAddressResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NewStaticAddress not implemented")
}
func (UnimplementedSwapClientServer) ListUnspentDeposits(context.Context, *ListUnspentDepositsRequest) (*ListUnspentDepositsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUnspentDeposits not implemented")
}
func (UnimplementedSwapClientServer) WithdrawDeposits(context.Context, *WithdrawDepositsRequest) (*WithdrawDepositsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WithdrawDeposits not implemented")
}
func (UnimplementedSwapClientServer) ListStaticAddressDeposits(context.Context, *ListStaticAddressDepositsRequest) (*ListStaticAddressDepositsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStaticAddressDeposits not implemented")
}
func (UnimplementedSwapClientServer) ListStaticAddressWithdrawals(context.Context, *ListStaticAddressWithdrawalRequest) (*ListStaticAddressWithdrawalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStaticAddressWithdrawals not implemented")
}
func (UnimplementedSwapClientServer) ListStaticAddressSwaps(context.Context, *ListStaticAddressSwapsRequest) (*ListStaticAddressSwapsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListStaticAddressSwaps not implemented")
}
func (UnimplementedSwapClientServer) GetStaticAddressSummary(context.Context, *StaticAddressSummaryRequest) (*StaticAddressSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStaticAddressSummary not implemented")
}
func (UnimplementedSwapClientServer) StaticAddressLoopIn(context.Context, *StaticAddressLoopInRequest) (*StaticAddressLoopInResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StaticAddressLoopIn not implemented")
}
func (UnimplementedSwapClientServer) mustEmbedUnimplementedSwapClientServer() {}
func (UnimplementedSwapClientServer) testEmbeddedByValue()                    {}

// UnsafeSwapClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SwapClientServer will
// result in compilation errors.
type UnsafeSwapClientServer interface {
	mustEmbedUnimplementedSwapClientServer()
}

func RegisterSwapClientServer(s grpc.ServiceRegistrar, srv SwapClientServer) {
	// If the following call panics, it indicates UnimplementedSwapClientServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SwapClient_ServiceDesc, srv)
}

func _SwapClient_LoopOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_LoopOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOut(ctx, req.(*LoopOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_LoopIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopIn(ctx, req.(*LoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapClientServer).Monitor(m, &grpc.GenericServerStream[MonitorRequest, SwapStatus]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SwapClient_MonitorServer = grpc.ServerStreamingServer[SwapStatus]

func _SwapClient_ListSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListSwaps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListSwaps(ctx, req.(*ListSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SwapInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SwapInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_SwapInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SwapInfo(ctx, req.(*SwapInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_AbandonSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbandonSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).AbandonSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_AbandonSwap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).AbandonSwap(ctx, req.(*AbandonSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_LoopOutTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_LoopOutQuote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetLoopInTerms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetLoopInQuote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_Probe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).Probe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_Probe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).Probe(ctx, req.(*ProbeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetL402Tokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetL402Tokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetL402Tokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetL402Tokens(ctx, req.(*TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLsatTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLsatTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetLsatTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLsatTokens(ctx, req.(*TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_FetchL402Token_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchL402TokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).FetchL402Token(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_FetchL402Token_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).FetchL402Token(ctx, req.(*FetchL402TokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDaemonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).StopDaemon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_StopDaemon_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).StopDaemon(ctx, req.(*StopDaemonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLiquidityParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiquidityParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLiquidityParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetLiquidityParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLiquidityParams(ctx, req.(*GetLiquidityParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SetLiquidityParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLiquidityParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SetLiquidityParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_SetLiquidityParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SetLiquidityParams(ctx, req.(*SetLiquidityParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SuggestSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SuggestSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_SuggestSwaps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SuggestSwaps(ctx, req.(*SuggestSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListReservations(ctx, req.(*ListReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_InstantOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstantOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).InstantOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_InstantOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).InstantOut(ctx, req.(*InstantOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_InstantOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstantOutQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).InstantOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_InstantOutQuote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).InstantOutQuote(ctx, req.(*InstantOutQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListInstantOuts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstantOutsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListInstantOuts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListInstantOuts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListInstantOuts(ctx, req.(*ListInstantOutsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_NewStaticAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewStaticAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).NewStaticAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_NewStaticAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).NewStaticAddress(ctx, req.(*NewStaticAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListUnspentDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnspentDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListUnspentDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListUnspentDeposits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListUnspentDeposits(ctx, req.(*ListUnspentDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_WithdrawDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).WithdrawDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_WithdrawDeposits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).WithdrawDeposits(ctx, req.(*WithdrawDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListStaticAddressDeposits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStaticAddressDepositsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListStaticAddressDeposits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListStaticAddressDeposits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListStaticAddressDeposits(ctx, req.(*ListStaticAddressDepositsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListStaticAddressWithdrawals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStaticAddressWithdrawalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListStaticAddressWithdrawals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListStaticAddressWithdrawals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListStaticAddressWithdrawals(ctx, req.(*ListStaticAddressWithdrawalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_ListStaticAddressSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStaticAddressSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListStaticAddressSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_ListStaticAddressSwaps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListStaticAddressSwaps(ctx, req.(*ListStaticAddressSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetStaticAddressSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StaticAddressSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetStaticAddressSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_GetStaticAddressSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetStaticAddressSummary(ctx, req.(*StaticAddressSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_StaticAddressLoopIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StaticAddressLoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).StaticAddressLoopIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SwapClient_StaticAddressLoopIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).StaticAddressLoopIn(ctx, req.(*StaticAddressLoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SwapClient_ServiceDesc is the grpc.ServiceDesc for SwapClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SwapClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "looprpc.SwapClient",
	HandlerType: (*SwapClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoopOut",
			Handler:    _SwapClient_LoopOut_Handler,
		},
		{
			MethodName: "LoopIn",
			Handler:    _SwapClient_LoopIn_Handler,
		},
		{
			MethodName: "ListSwaps",
			Handler:    _SwapClient_ListSwaps_Handler,
		},
		{
			MethodName: "SwapInfo",
			Handler:    _SwapClient_SwapInfo_Handler,
		},
		{
			MethodName: "AbandonSwap",
			Handler:    _SwapClient_AbandonSwap_Handler,
		},
		{
			MethodName: "LoopOutTerms",
			Handler:    _SwapClient_LoopOutTerms_Handler,
		},
		{
			MethodName: "LoopOutQuote",
			Handler:    _SwapClient_LoopOutQuote_Handler,
		},
		{
			MethodName: "GetLoopInTerms",
			Handler:    _SwapClient_GetLoopInTerms_Handler,
		},
		{
			MethodName: "GetLoopInQuote",
			Handler:    _SwapClient_GetLoopInQuote_Handler,
		},
		{
			MethodName: "Probe",
			Handler:    _SwapClient_Probe_Handler,
		},
		{
			MethodName: "GetL402Tokens",
			Handler:    _SwapClient_GetL402Tokens_Handler,
		},
		{
			MethodName: "GetLsatTokens",
			Handler:    _SwapClient_GetLsatTokens_Handler,
		},
		{
			MethodName: "FetchL402Token",
			Handler:    _SwapClient_FetchL402Token_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _SwapClient_GetInfo_Handler,
		},
		{
			MethodName: "StopDaemon",
			Handler:    _SwapClient_StopDaemon_Handler,
		},
		{
			MethodName: "GetLiquidityParams",
			Handler:    _SwapClient_GetLiquidityParams_Handler,
		},
		{
			MethodName: "SetLiquidityParams",
			Handler:    _SwapClient_SetLiquidityParams_Handler,
		},
		{
			MethodName: "SuggestSwaps",
			Handler:    _SwapClient_SuggestSwaps_Handler,
		},
		{
			MethodName: "ListReservations",
			Handler:    _SwapClient_ListReservations_Handler,
		},
		{
			MethodName: "InstantOut",
			Handler:    _SwapClient_InstantOut_Handler,
		},
		{
			MethodName: "InstantOutQuote",
			Handler:    _SwapClient_InstantOutQuote_Handler,
		},
		{
			MethodName: "ListInstantOuts",
			Handler:    _SwapClient_ListInstantOuts_Handler,
		},
		{
			MethodName: "NewStaticAddress",
			Handler:    _SwapClient_NewStaticAddress_Handler,
		},
		{
			MethodName: "ListUnspentDeposits",
			Handler:    _SwapClient_ListUnspentDeposits_Handler,
		},
		{
			MethodName: "WithdrawDeposits",
			Handler:    _SwapClient_WithdrawDeposits_Handler,
		},
		{
			MethodName: "ListStaticAddressDeposits",
			Handler:    _SwapClient_ListStaticAddressDeposits_Handler,
		},
		{
			MethodName: "ListStaticAddressWithdrawals",
			Handler:    _SwapClient_ListStaticAddressWithdrawals_Handler,
		},
		{
			MethodName: "ListStaticAddressSwaps",
			Handler:    _SwapClient_ListStaticAddressSwaps_Handler,
		},
		{
			MethodName: "GetStaticAddressSummary",
			Handler:    _SwapClient_GetStaticAddressSummary_Handler,
		},
		{
			MethodName: "StaticAddressLoopIn",
			Handler:    _SwapClient_StaticAddressLoopIn_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Monitor",
			Handler:       _SwapClient_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client.proto",
}
